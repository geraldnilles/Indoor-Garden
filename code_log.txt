
The initial plan was to use a simple analog comparitor.  THis comparitor would
be high if the LED current was above 20mA and low when it was below 20mA.  After
some simulations, I found that this would only work for stead state operation.
It would not work for initial start up.  If this algorithm was used to switch
the mosfet, it would result in a HUGE overshoot and blow up all of the
electronics.

Therefore, we will need software that provides a soft startup.  We would need to
slowly ramp up the LED current and then start using the analog comparitor.  

The softstart will begin with a low duty cycle.  The frequency and period will
be chosen based on the inductance, capacitance, and input voltage.  Every 100ms,
the duty cycle will increase 1% until the LED current is above 20mA.  From there
the stead state operation will begin.

Pseudo Code:

// Soft Start
on_time =  XX; // This will be 170/inductance/(max inductor current)
off_time = on_time*100
counter = 0
while( LED current is under 20mA):
	if counter < on_time:
		Switch On
	else
		Switch Off
	if counter > on_time+off_time:
		counter = 0

// Steady State Mode


After rethinking this, there may be a reason why the circuit may want to
reinitialize softstare mode.  In this case, it would be bad to have 2 separate
loops.  Instead, we could simply add a "Maximum On Time" for the switch.  If
that is ever reached, the switch will be turned off for a period of time before
the loop restarts.  This type of loop would allow a single loops that can
handle start up and stead state.

The improved loop will have a minimum on time, a maximum on time, a minimum off
time and a maximum off time. Using these 4 rules plus the LED current, we should
be able to create a decent loop.  There will be an on time and an off time (both
in us) which will be slowly adjusted within their limits.  

Pseudo Code:
unsigned short on_time = minimum on time
unsigned short off_time = maximum off time
unsigned short MAX_ON_TIME  // Based on maximum inductor current rating
unsigned short MIN_ON_TIME  // Based on Gate Driver Limits
unsigned short MAX_OFF_TIME // Based on Counter length
unsigned short MIN_OFF_TIME // Based on Gate Driver Limits

Start Running Timter 0

Turn Switch On
TCNT0 = 0 // Reset Counter

On Loop:
	if LED current is high:
		if TCNT0 > MIN_ON_TIME:
			Turn Switch Off
			TCNT0 = 0
			Jump to Off Loop
	else:
		if TCNT0 > MAX_ON_TIME:
			Turn Switch Off
			TCNT0 = 0

5/6/2012

After thinking about this, it probably makes more sense just to use an ADC and a
slowly changing PWM.  Initially, the Duty cycle will be set to the minimum
(based on the gate driver capabilities).  The ADC will be used to measure the
LED current.  

To be safe, we will want the PWM decrease rate to be faster than the PWM
increase rate.  So the MCU will slowly ramp up the voltage, but quickly ramp
down the speed.  All of the work will be done in the ADC interrupt function.

Code:

below_count = 0

ADC Interrupt(current):
	if current > target // Target will probably be 20mA
		Decrease Duty Cycle by 1
		below_count = 0
	else: // Current under the target
		below_count++;  // The below count will be used to control
				// how slowly the duty cycle ramps up
		if below_count > 5:
			Increase Duty Cycle by 1

	Restart the ADC
